<html>
  <head>
    <title>Phone Party</title>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
  </head>
  <body>
    <div id="introduction-page" class="hide">
      <h1>Join our game!</h1>
      <h2>1. Connect to the Game Jam WiFi</h2>
      <p>sid: ??  password: ??</p>
      <h2>2. Go to <em>jam.joshshone.com</em><h2>
    </div>
    <div id="pause-indicator">⏸</div>
    <div id="connection-status"></div>
    <div id="warning-indicator"></div>
  </body>
  <script>
    "use strict";

    // HTTPS redirect
    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && !location.hostname.startsWith('192.168.') && location.protocol !== 'file:') {
      location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
    }

    const connectionStatus = document.getElementById('connection-status');
    const warningIndicator = document.getElementById('warning-indicator');

    if (location.protocol === 'file:') {
      const message = 'Cannot open websocket because this page is loaded with the file protocol.';
      connectionStatus.className = 'error';
      connectionStatus.textContent = message;
      throw message;
    }

    const players = [];

    (async function() {
      connectionStatus.className = 'connecting';
      while (true) {
        const websocket = new WebSocket(`${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.hostname}:${location.port}/host`);
        websocket.onopen = () => connectionStatus.className = '';

        websocket.onmessage = event => {
          const message = JSON.parse(event.data);
          if (message.type !== 'playerDisconnected' && JSON.parse(message.message).sdp) {
            handleNewPlayer(message.playerId, JSON.parse(message.message).sdp, websocket);
          }
        }
        
        await new Promise(resolve => websocket.onclose = resolve);
        warningIndicator.textContent = 'Websocket disconnected, reconnecting in 5 seconds';
        await new Promise(resolve => setTimeout(() => resolve(), 5000));
        warningIndicator.textContent = 'Websocket reconnecting..';
        await new Promise(resolve => setTimeout(() => resolve(), 1000));
        warningIndicator.textContent = '';
      }
    })();
    
    function receiveMessageFromWebsocket() {
      return new Promise(resolve => websocket.addEventListener('message', event => resolve(JSON.parse(event.data)), {once: true}));
    }

    async function handleNewPlayer(playerId, sdp, websocket) {
      const player = document.createElement('div');

      const rtcConnection = new RTCPeerConnection();
      let hasSentSdp = false;
      const iceCandidatesToSend = [];
      rtcConnection.onicecandidate = event => {
        if (event.candidate) {
          iceCandidatesToSend.push(JSON.stringify(event.candidate.toJSON()));
          if (hasSentSdp) {
            while (iceCandidatesToSend.length) websocket.send(JSON.stringify({playerId: playerId, type: 'ice', message: iceCandidatesToSend.pop()}));
          }
        }
      }

      const video = document.createElement('video');
      player.video = video;
      video.autoplay = true;
      video.muted = true;
      rtcConnection.ontrack = event => {
        if (video.srcObject !== event.streams[0]) {
          video.srcObject = event.streams[0];
          player.appendChild(video);
        }
      }

      websocket.addEventListener('message', function callback() {
        const message = JSON.parse(event.data);
        if (message.playerId === playerId) {
          if (message.type === 'playerDisconnected') {
            websocket.removeEventListener('message', callback);
          } else if (message.type === 'ice') {
            rtcConnection.addIceCandidate(JSON.parse(JSON.parse(message.message).iceCandidate));
          }
        }
      });

      await rtcConnection.setRemoteDescription({type: 'offer', sdp: sdp});

      const buttonsChannel          = rtcConnection.createDataChannel('buttons',         {negotiated: true, id: 1, ordered: true});
      player.wheelChannel           = rtcConnection.createDataChannel('wheel',           {negotiated: true, id: 2, ordered: true});
      const accelerometerChannel    = rtcConnection.createDataChannel('accelerometer',   {negotiated: true, id: 3, ordered: false, maxRetransmits: 0});
      const visibilityChannel       = rtcConnection.createDataChannel('visibility',      {negotiated: true, id: 5, ordered: true});
      player.hostInteractionChannel = rtcConnection.createDataChannel('hostInteraction', {negotiated: true, id: 6, ordered: true});
      const closeChannel            = rtcConnection.createDataChannel('close',           {negotiated: true, id: 7, ordered: true});

      const answer = await rtcConnection.createAnswer();
      rtcConnection.setLocalDescription(answer);
      websocket.send(JSON.stringify({playerId: playerId, type: 'sdp', message: answer.sdp}));
      hasSentSdp = true;
      while (iceCandidatesToSend.length) websocket.send(JSON.stringify({playerId: playerId, type: 'ice', message: iceCandidatesToSend.pop()}));

      // Wait for RTC connection to connect
      await new Promise((resolve, reject) => {
        rtcConnection.onconnectionstatechange = () => {
          if (rtcConnection.connectionState === 'connected') {
            resolve();
          } else if (rtcConnection.connectionState === 'failed') {
            reject();
          }
        }
      });

      player.classList.add('player', 'new');
      setTimeout(() => player.classList.remove('new'), 4000);
      player.style.left = (Math.random() * 100) + 'vw';
      player.style.top  = 30 + (Math.random() * 70) + 'vh';

      player.onpointerdown = event => {
        player.setPointerCapture(event.pointerId);
        if (player.hostInteractionChannel.readyState === 'open') {
          player.hostInteractionChannel.send('drag start');
        }
        function mousemove(event) {
          player.style.left = ((event.pageX / window.innerWidth)  * 100) + 'vw';
          player.style.top  = ((event.pageY / window.innerHeight) * 100) + 'vh';
        }
        window.addEventListener('pointermove', mousemove);
        window.addEventListener('pointerup', event => {
          window.removeEventListener('pointermove', mousemove);
          if (player.hostInteractionChannel.readyState === 'open') {
            player.hostInteractionChannel.send('drag end');
          }
        });
      }

      document.body.appendChild(player);
      players.push(player);

      const buttonStates = {};

      const momentum = {x: 0, y: 0};
      let lastTimestamp = performance.now();
      window.requestAnimationFrame(function handleFrame(timestamp) {
        if (!player.parentElement) {
          return;
        }
        const delta = timestamp - lastTimestamp;
        const playerRadius = 6;

        // Bounce back from edges of screen
        const bounceBack = 0.015;
        if (parseFloat(player.style.left) < playerRadius)       momentum.x += bounceBack * delta;
        if (parseFloat(player.style.top)  < playerRadius)       momentum.y -= bounceBack * delta;
        if (parseFloat(player.style.left) > 100 - playerRadius) momentum.x -= bounceBack * delta;
        if (parseFloat(player.style.top)  > 100 - playerRadius) momentum.y += bounceBack * delta;

        const playerMovementSpeed = 0.012;
        if (buttonStates['left'])  momentum.x -= playerMovementSpeed * delta;
        if (buttonStates['right']) momentum.x += playerMovementSpeed * delta;
        if (buttonStates['down'])  momentum.y -= playerMovementSpeed * delta;
        if (buttonStates['up'])    momentum.y += playerMovementSpeed * delta;
        
        if (!(player.classList.contains('not-player-moveable') || player.classList.contains('fullscreen'))) {
          player.style.left = ((parseFloat(player.style.left) || 0) + momentum.x) + 'vw';
          player.style.top  = ((parseFloat(player.style.top) || 0) - momentum.y) + 'vh';
        }

        // Apply friction
        const friction = 0.005;
        momentum.x *= Math.max(0, 1 - (delta * friction));
        momentum.y *= Math.max(0, 1 - (delta * friction));
        lastTimestamp = timestamp;
        window.requestAnimationFrame(handleFrame);
      });

      buttonsChannel.onmessage = event => {
        const [button, state] = event.data.split(' ');
        buttonStates[button] = state === 'true';
        if (button === 'ping') {
          player.classList.toggle('pinging', state === 'true');
        }
      }

      accelerometerChannel.onmessage = event => {
        const acceleration = JSON.parse(event.data);
        const wiggle = 0.5;
        player.style.transform = `translate(${(acceleration.x * wiggle) + 'vw'}, ${(acceleration.y * -wiggle) + 'vw'})`;
      }

      visibilityChannel.onmessage = event => player.dataset.visibility = event.data;

      window.onbeforeunload = () => {
        if (closeChannel.readyState === 'open') {
          closeChannel.send('true');
        }
      }

      document.body.dispatchEvent(new Event('playerAdded'));

      const rtcConnectionClosed = new Promise(resolve => {
        rtcConnection.addEventListener('connectionstatechange', function callback() {
          if (rtcConnection.connectionState === 'failed' || rtcConnection.connectionState === 'closed') {
            resolve();
            rtcConnection.removeEventListener('connectionstatechange', callback);
          }
        });
      });

      const rtcCloseSignalReceived = new Promise(resolve => closeChannel.onmessage = resolve);

      await Promise.race([rtcConnectionClosed, rtcCloseSignalReceived]);

      rtcConnection.close();

      player.classList.add('leaving');
      player.dataset.visibility = '';
      setTimeout(() => player.remove(), 200);
      players.splice(players.indexOf(player), 1);
    }

    let paused = false;
    window.addEventListener('keydown', event => {
      if (event.key === 'p') {
        paused = !paused;
        document.getElementById('pause-indicator').classList.toggle('activated', paused);
      }
    });

    // Game logic
    (async function() {
      await showElement(document.getElementById('introduction-page'));

      while (true) {

        await countdown(8);

        const player = await randomPlayerSelection("Who's next?");
        if (player) {
          player.classList.add('fullscreen');
          player.style.left = '';
          player.style.top = '';
          await countdown(20);
          player.classList.remove('fullscreen');
          player.style.left = '0vw';
          player.style.top = '0vh';
        }
        
        await countdown(8);

        await vote('Vote!');
      }
    })();

    async function showElement(element) {
      element.classList.remove('hide');
      await waitForKeypress(' ');
      element.classList.add('hide');
    }

    async function countdown(seconds = 10, title = '', detail = '') {
      const div = document.createElement('div');
      div.classList.add('countdown');
      document.body.appendChild(div);
      const titleDiv = document.createElement('div');
      titleDiv.classList.add('countdown-title');
      titleDiv.textContent = title;
      document.body.appendChild(titleDiv);
      const detailDiv = document.createElement('div');
      detailDiv.classList.add('countdown-detail');
      if (detail) {
        detailDiv.innerHTML = detail;
      }
      document.body.appendChild(detailDiv);
      for (let n = seconds; n > 0; n--) {
        div.textContent = '⏲' + n;
        const result = await Promise.race([waitForNSeconds(1), waitForKeypress(' ')]);
        if (result && result.type === 'keypress') {
          break;
        }
      }
      titleDiv.remove();
      detailDiv.remove();
      div.textContent = "Let's go!";
      await Promise.race([waitForNSeconds(3), waitForKeypress(' ')]);
      div.remove();
    }

    async function randomPlayerSelection(title) {
      const titleDiv = document.createElement('div');
      titleDiv.classList.add('wheel-title');
      titleDiv.textContent = title;
      document.body.appendChild(titleDiv);
      const wheelTicker = document.createElement('div');
      wheelTicker.classList.add('wheel-ticker');
      document.body.appendChild(wheelTicker);

      const result = await Promise.race([waitForPlayers(), waitForKeypress(' ')]);
      if (result && result.type === 'keypress') {
        titleDiv.remove();
        wheelTicker.remove();
        return null;
      }

      for (const player of players) player.classList.add('not-player-moveable');

      const wheelRevolutions = 5;
      const wheelSpinTimeMs = 10000;
      const wheelStartingAngle = Math.PI*2*Math.random();
      const firstTimestamp = performance.now();
      let skipped = false;
      let lastPlayerChosen = null;
      waitForKeypress(' ').then(event => {
        skipped = true;
      });
      const player = await new Promise(resolve => {
        window.requestAnimationFrame(function handleFrame(timestamp) {
          const timeSinceStart = timestamp - firstTimestamp;
          const spinCompletionRatio = timeSinceStart / wheelSpinTimeMs;
          function easeOutCubic(t) { return (--t)*t*t+1 }
          const wheelAngle = wheelStartingAngle + (Math.PI*2*wheelRevolutions * easeOutCubic(spinCompletionRatio));
          for (const [index, player] of players.entries()) {
            const playerAngle = wheelAngle + (Math.PI*2*(index / players.length));
            player.style.left = (50 + (30 * Math.cos(playerAngle - (Math.PI/2)))) + 'vw';
            player.style.top  = (60 + (30 * Math.sin(playerAngle - (Math.PI/2)))) + 'vh';
          }
          const chosenPlayer = players.length > 0 ? players[(players.length-1) - ((Math.floor(players.length * (wheelAngle / (Math.PI*2))) + (players.length-1)) % players.length)] : null;
          if (chosenPlayer !== lastPlayerChosen) {
            if (lastPlayerChosen !== null) {
              lastPlayerChosen.classList.remove('chosen');
              if (lastPlayerChosen.wheelChannel.readyState === 'open') {
                lastPlayerChosen.wheelChannel.send('not chosen');
              }
            }
            if (chosenPlayer !== null) {
              chosenPlayer.classList.add('chosen');
              if (chosenPlayer.wheelChannel.readyState === 'open') {
                chosenPlayer.wheelChannel.send('chosen');
              }
            }
          }
          lastPlayerChosen = chosenPlayer;
          if (timeSinceStart >= wheelSpinTimeMs || skipped) {
            if (chosenPlayer !== null) {
              chosenPlayer.classList.remove('chosen');
              chosenPlayer.classList.add('flash');
              setTimeout(() => chosenPlayer.classList.remove('flash'), 1000);
              if (chosenPlayer.wheelChannel.readyState === 'open') {
                chosenPlayer.wheelChannel.send('chosen final');
                setTimeout(() => {
                  if (chosenPlayer.wheelChannel.readyState === 'open') {
                    chosenPlayer.wheelChannel.send('not chosen');
                  }
                }, 1000);
              }
              resolve(chosenPlayer);
            } else {
              resolve(null);
            }
            return;
          }
          window.requestAnimationFrame(handleFrame);
        });
      });
      await Promise.race([waitForNSeconds(1), waitForKeypress(' ')]);
      for (const player of players) {
        player.classList.remove('not-player-moveable');
        player.classList.remove('chosen');
      }
      titleDiv.remove();
      wheelTicker.remove();
      return player;
    }

    async function vote(topic = '', optionA = 'no', optionB = 'yes', countdownSeconds = 20) {
      document.body.insertAdjacentHTML('beforeend', `
        <div class="voting-field">
          <div class="option-a">${optionA}</div>
          <div class="option-b">${optionB}</div>
          <div class="swing-arrow"></div>
          <div class="voting-text">${topic}</div>
          <div class="voting-countdown"></div>
          <div class="you-selected">You selected:</div>
        </div>
      `);
      const field = document.body.lastElementChild;

      if (players.length === 0) {
        const result = await Promise.race([waitForPlayers(), waitForKeypress(' ')]);
        if (result && result.type === 'keypress') {
          field.remove();
          return null;
        }
      }
      
      let isVoting = true;
      window.requestAnimationFrame(function handleFrame() {
        if (!isVoting) return;
        const swing = players.map(player => (parseFloat(player.style.left) - 50) / 50).reduce((a, swing) => a + swing, 0) / players.length;
        field.querySelector('.swing-arrow').style.transform = `rotate(${45 * -swing}deg)`;
        field.classList.toggle('option-a', swing <  0);
        field.classList.toggle('option-b', swing >= 0);
        window.requestAnimationFrame(handleFrame);
      });

      for (let n=countdownSeconds; n>0; n--) {
        field.querySelector('.voting-countdown').textContent = n;
        const result = await Promise.race([waitForNSeconds(1), waitForKeypress(' ')]);
        if (result && result.type === 'keypress') {
          break;
        }
      }
      isVoting = false;
      field.classList.add('finished');
      field.querySelector('.swing-arrow').remove();
      await Promise.race([waitForNSeconds(5), waitForKeypress(' ')]);

      field.remove();
      return field.classList.contains('option-a') ? 'a' : 'b';
    }

    async function showText(text, seconds, backgroundColor) {
      const textDiv = document.createElement('div');
      textDiv.classList.add('fullscreen-text');
      if (backgroundColor) {
        textDiv.style.backgroundColor = backgroundColor;
        textDiv.style.color = 'white';
      }
      textDiv.textContent = text;
      document.body.appendChild(textDiv);
      await Promise.race([waitForNSeconds(seconds), waitForKeypress(' ')]);
      textDiv.remove();
    }

    async function waitForPlayers(n = 1) {
      return new Promise(resolve => {
        if (players.length >= n) {
          resolve();
        } else {
          document.body.addEventListener('playerAdded', function callback() {
            if (players.length >= n) {
              resolve();
              document.body.removeEventListener('playerAdded', callback);
            }
          });
        }
      });
    }

    function waitForNSeconds(seconds) {
      return new Promise(resolve => {
        setTimeout(() => {
          if (paused) {
            waitForKeypress('p').then(() => resolve());
          } else {
            resolve();
          }
        }, 1000 * seconds);
      });
    }

    function waitForKeypress(key) {
      return new Promise(resolve => {
        window.addEventListener('keypress', function handleKeypress(event) {
          if (event.key === key) {
            resolve(event);
            window.removeEventListener('keypress', handleKeypress);
          }
        });
      });
    }
  </script>
  <style>
    body {
      margin: 0;
      background-color: orange;
    }
    #connection-status {
      position: fixed;
      width:  100%;
      height: 100%;
      display: none;
      flex-direction: column;
      background-color: #fff;
      text-align:      center;
      justify-content: center;
      align-items:     center;
      font-size: 5vw;
    }
    #connection-status.connecting { display: flex; background-color: blue; }
    #connection-status.error      { display: flex; background-color: red;  }
    #connection-status::before {
      font-size: 10vw;
    }
    #connection-status.connecting::before { content: 'Connecting..'; }
    #connection-status.error::before      { content: 'Error';        }
    #warning-indicator {
      position: fixed;
      top: 0;
      right: 0;
      background-color: #fff;
      color: red;
    }
    #introduction-page {
      position: fixed;
      left: 0;
      top:  0;
      width:  100%;
      height: 100%;
      font-size: 5vmin;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #introduction-page h2 {
      margin-bottom: 0;
    }
    .hide {
      display: none !important;
    }
    .player {
      position: fixed;
      width:  12vw;
      height: 12vw;
      margin-left: -6vw;
      margin-top:  -6vw;
      border-radius: 12vw;
      box-sizing: border-box;
      z-index: 2;
      background-color: grey;
      opacity: 0.8;
      overflow: hidden;
      cursor: pointer;
    }
    .player.new {
      transform: scale(0);
      animation: 0.5s both scaleup;
/*       animation-delay: 2s; */
    }
    @keyframes scaleup {
      0%   { transform: scale(0); }
      30%  { transform: scale(1.2); }
      55%  { transform: scale(0.9); }
      75%  { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .player.leaving {
      transform: scale(1);
      animation: 0.2s ease-in forwards scaledown;
    }
    @keyframes scaledown {
      from { transform: scale(1); }
      to   { transform: scale(0); }
    }
    .player video {
      object-fit: cover;
      transform: scale(-1, 1);
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
      border-radius: 50%;
    }
    .player.pinging {
      width:  30vw;
      height: 30vw;
      margin-left: -15vw;
      margin-top: -15vw;
      border-radius: 15vw;
      z-index: 2;
    }
    .player.pinging video {
      transform: scale(-1.5, 1.5);
    }
    .player[data-visibility='hidden'] {
      overflow: visible;
    }
    .player[data-visibility='hidden']:before {
      content: '';
      position: absolute;
      left: 0;
      top:  0;
      width:  150%;
      height: 150%;
      z-index: 2;
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNi43IDEyLjQiIGhlaWdodD0iNDciIHdpZHRoPSI2MyI+PHBhdGggZD0iTTMgOS41djEuNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMTU5Y2QwIiBzdHJva2Utd2lkdGg9IjEuOCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+PHBhdGggZD0iTTcuMSAxMGMtLjQuOC0xLjIgMC0zIDBzLTIuNC45LTMgMGMtLjQtLjcgMS0yIDMtMiAxLjkgMCAzLjUgMS4zIDMgMnoiLz48cGF0aCBkPSJNLjkgNS42Yy41LjggMS40LjggMS45IDBNNS41IDUuNmMuNS44IDEuNC44IDEuOSAwIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iLjgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik03LjYgMS41bDItLjUtMS4yIDMgMS45LS41IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iLjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIGQ9Ik0xMS40IDEuMWwxLjUtLjMtMSAyLjIgMS40LS4zIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjxwYXRoIGQ9Ik0xNC42LjhsMS4xLS4yLS44IDEuNyAxLS4yIiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iLjQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==');
      background-repeat: no-repeat;
      background-size: 81%;
      background-position: 64% -8%;
    }
    .player[data-visibility='hidden'] video {
      opacity: 0.25;
    }
    .player.chosen:after {
      content: '';
      display: block;
      position: absolute;
      left:   0;
      top:    0;
      right:  0;
      bottom: 0;
      border-radius: 50%;
      background-color: blue;
      opacity: 0.7;
    }
    .player.flash:after {
      content: '';
      position: absolute;
      left:   0;
      top:    0;
      right:  0;
      bottom: 0;
      border-radius: 50%;
      background-color: blue;
      opacity: 0.7;
      animation: 0.2s steps(2) flash 5;
    }
    .player.fullscreen {
      border-radius: 0;
      left: 0;
      top: 0;
      width:  100vw;
      height: 100vh;
      margin-left: 0;
      margin-top: 0;
      z-index: -1;
    }
    .player.fullscreen video {
      border-radius: 0;
    }
    @keyframes flash {
      from { opacity: 1; }
      to   { opacity: 0; }
    }
    #pause-indicator {
      display: none;
    }
    #pause-indicator.activated {
      position: fixed;
      z-index: 4;
      left: 0;
      top:  0;
      width:  5vw;
      height: 5vw;
      font-size: 4vw;
      display: flex;
      justify-content: center;
      align-items:     center;
      color: white;
      background-color: black;
      border-bottom-right-radius: 2vw;
    }
    .countdown {
      position: fixed;
      z-index: 3;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      font-size: 10vw;
      display: flex;
      justify-content: center;
      align-items: center;
      text-shadow: white 2px 2px, white -2px -2px, white -2px 2px, white 2px -2px;
      pointer-events: none;
    }
    .countdown-title {
      position: fixed;
      z-index: 3;
      left: 0;
      top: 0;
      height: 40vh;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 5vw;
      text-shadow: white 2px 2px, white -2px -2px, white -2px 2px, white 2px -2px;
      pointer-events: none;
    }
    .countdown-detail {
      position: fixed;
      z-index: 3;
      left: 0;
      top: 60vh;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 4vw;
      text-shadow: white 2px 2px, white -2px -2px, white -2px 2px, white 2px -2px;
      pointer-events: none;
    }
    em {
      background-color: black;
      color: white;
      text-shadow: none;
    }
    .wheel-title {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      font-size: 6vw;
      text-align: center;
    }
    .wheel-ticker {
      display: block;
      position: fixed;
      left: 50vw;
      top: 5vw;
      width: 10vw;
      height: 10vw;
      margin-left: -5vw;
      background-repeat: no-repeat;
      background-size: 100%;
      transform: rotate(180deg);
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEgMSIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cGF0aCBkPSJNIDAsMC44IDAuNSwwLjIgMSwwLjggeiIgc3R5bGU9ImZpbGw6IzAwMDBmZjtzdHJva2U6bm9uZTsiIC8+PC9zdmc+');
    }
    .voting-field {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      font-size: 5vw;
      background-color: white;
    }
    .voting-field .option-a {
      position: absolute;
      left: 0;
      width: 50%;
      top: 15vw;
      bottom: 0;
      background-color: red;
      content: 'Nein';
      text-align: center;
      z-index: -1;
    }
    .voting-field.option-a .option-a {
      font-size: 8vw;
      font-weight: bold;
    }
    .voting-field .option-b {
      position: absolute;
      left: 50%;
      width: 50%;
      top: 15vw;
      bottom: 0;
      background-color: green;
      content: 'Ja';
      text-align: center;
      z-index: -1;
    }
    .voting-field.option-b .option-b {
      font-size: 8vw;
      font-weight: bold;
    }
    .voting-field.finished.option-b .option-b { left: 0; width: 100%; padding-top: 14vw; }
    .voting-field.finished.option-b .option-a { display: none; }
    .voting-field.finished.option-a .option-a { left: 0; width: 100%; padding-top: 14vw; }
    .voting-field.finished.option-a .option-b { display: none; }
    .voting-field .you-selected {
      display: none;
    }
    .voting-field.finished .you-selected {
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      top: 15vw;
      font-size: 5vw;
      text-align: center;
    }
    .voting-field .swing-arrow {
      position: absolute;
      z-index: 3;
      left: 50%;
      top: 15vw;
      width: 5vw;
      height: 20vw;
      z-index: 1;
      margin-left: -2.5vw;
      background-color: grey;
      transform-origin: 2.5vw 0;
    }
    .voting-field .swing-arrow:after {
      content: '';
      position: absolute;
      top: 90%;
      left: -47%;
      width: 10vw;
      height: 10vw;
      transform: rotate(180deg);
      background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEgMSIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cGF0aCBkPSJNIDAsMC44IDAuNSwwLjIgMSwwLjggeiIgc3R5bGU9ImZpbGw6IzAwMDBmZjtzdHJva2U6bm9uZTsiIC8+PC9zdmc+');
      background-repeat: no-repeat;
      background-size: 100%;
    }
    .voting-field .voting-text {
      position: absolute;
      z-index: 3;
      left: 0;
      top: 0;
      right: 0;
      height: 15vw;
      text-align: center;
      padding-left:  5vw;
      padding-right: 5vw;
      padding-top: 1vw;
    }
    .voting-field .voting-countdown {
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      top: 12vw;
      left: 50%;
      z-index: 1;
      font-size: 4vw;
      background-color: grey;
      width: 6vw;
      height: 6vw;
      border-radius: 3vw;
      margin-left: -3vw;
    }
    .voting-field.finished .voting-countdown {
      display: none;
    }
    .fullscreen-text {
      display: flex;
      position: fixed;
/*       z-index: 3; */
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      font-size: 15vw;
      justify-content: center;
      align-items: center;
    }
  </style>
</html>
